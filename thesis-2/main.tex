 \documentclass{SGGW-thesis}

\INZYNIERSKAtrue
\WZIMtrue

\title{Analiza działania oraz odtworzenie narzędzi front--endowych}
\Etitle{Analysis and reconstruction of front--end tools}
\author{Bartosz Osiński}
\date{2022}
\album{196097}
\thesis{Praca dyplomowa na kierunku:}
\course{Informatyka}
\promotor{dr.\ inż.\ Waldemara Karwowskiego, prof.\ SGGW}
\pworkplace{Instytut Informatyki Technicznej\\Katedra Sztucznej Inteligencji} % TODO

\usepackage{hyperref}

\begin{document}
\maketitle
\statementpage
\abstractpage % TODO napisać streszczenie i słowa kluczowe
{Stworzenie klasy \LaTeX-owej do użytku przy pisaniu pracy dyplomowej w SGGW}
{Tematem niniejszej pracy było zaimplementowanie klasy \LaTeX-owej pozwalającej na formatowanie tekstu zgodnie z wytycznymi nałożonymi przez uczelnię. Praca zawiera dwie
główne części. Pierwsza z nich zawiera opis najważniejszych aspektów implementacji klasy. Natomiast druga część skupia się na sposobie użycia klasy przez osoby piszące prace
dyplomowe.}
{LaTeX, klasa, praca dyplomowa, implementacja, SGGW, Szkoła Główna Gospodarstwa Wiejskiego}
{Creation of the \LaTeX\ Class to be Used When Writing a Thesis at the Warsaw University of Life Sciences -- SGGW}
{The subject of this study was to implement a \LaTeX\ class that allows for text formatting according to the guidelines imposed by the University. The work consists of two
main parts. The first one describes the most important aspects of the implementation. The second part focuses on how to use the class by people writing the theses.}
{LaTeX, class, thesis, implementation, SGGW, Warsaw University of Life Sciences}


{
  % Spis treści może być złożony z pojedynczą interlinią, np. jeśli jedna linia wychodzi na następną stronę.
  % W przeciwnym razie spis treści wstawić bez powyższego rozkazu i klamry.
  \doublespacing
  \tableofcontents
}

\startchapterfromoddpage % niezależnie od długości spisu treści pierwszy rozdział zacznie się na nieparzystej stronie


\chapter{Wstęp}
Współczesne aplikacje internetowe najczęściej składają się z dwóch części: front--endowej oraz back--endowej. Rozróżnienie między nimi polega na tym, gdzie kod jest wykonywany -- jeśli jest on wykonywany po stronie serwera, mówimy o back--endzie, natomiast jeśli obliczenia wykonywane są na komputerze użytkownika, jest to front--end.

Programowanie front--endowe jest jedną z najszybciej rozwijających się dziedzin programowania. Technologie, które pięć lat temu były zdecydowanymi liderami na rynku dziś są uważane za przestarzałe. Tak szybka ewolucja technik developerskich połączona z potrzebą kompatybilności wstecznej aplikacji internetowych (Właściciele aplikacji chcą, aby działały one dla jak największej grupy klientów, a nie tylko dla tych, którzy posiadają najnowsze wersje przeglądarek) generuje problemy, które deweloperzy rozwiązują używając między innymi szerokiego zakresu narzędzi front--endowych.

\section{Charakterystyka narzędzi front-endowych}
Podstawową cechą narzędzi front--endowych -- być może jedyną cechą wspólną dla większości narzędzi -- jest sposób ich konfiguracji. Większość narzędzi jest dostosowana do uruchomienia na dwa sposoby:
\begin{enumerate}
    \item Poprzez \emph{Command Line Interface} -- CLI -- wykonując krótki skrypt w wierszu poleceń takim jak np. Bash
    \item Jako kod, najczęściej w języku Javascript -- narzędzie dostarczane jest developerowi jako biblioteka programistyczna. Programista tworzy plik, który wywołuje funkcje z dostarczonej biblioteki z odpowiednimi argumentami. Następnie za każdym razem, kiedy chce uruchomić narzędzie musi uruchomić stworzony przez siebie plik, np. przy użyciu środowiska Node.js, jeśli kod jest napisany w języku javascript.
\end{enumerate}
Wiele narzędzi pozwala na uruchomienie ich przy użyciu obu tych metod: poprzez CLI w przypadkach, które nie wymagają skomplikowanej konfiguracji ani niestandardowych zachowań, oraz poprzez kod w bardziej skomplikowanych sytuacjach.

Wiele narzędzi łączy obie te metody w taki sposób, że programista tworzy plik, np. javascript, który eksportuje obiekt definiujący konfigurację, a następnie w wierszu poleceń uruchamia narzędzie przekazując mu tylko jeden argument -- ścieżkę do wspomnianego wcześniej pliku.

\section{Wybór typów narzędzi}
Praca ta ma na celu przeanalizowanie działania dwóch typów narzędzi frontendowych:
\begin{itemize}
    \item Module bundler -- Narzędzie, które łączy kod aplikacji rozdzielony na wiele plików w jeden plik, w ten sposób zamieniając kod przyjazny deweloperowi na wydajny kod wspierający starsze przeglądarki, które nie pozwalały na nowoczesne metody importowania i eksportowania symboli w plikach javascript. Przykładami istniejących narzędzi tego typu są \emph{Webpack} oraz \emph{Parcel}
    \item Generator CSS--owych klas atomicznych -- Narzędzie, które przeszukuje kod aplikacji, szukając w niej nazw klas, dla których mogą być zdefiniowane pewne style CSS, a następnie generuje plik CSS z odpowiednimi stylami. Przykładem może być \emph{Tailwind\cite{Tailwind_jit}} działający w trybie \emph{Just in Time} oraz \emph{UnoCSS\cite{unocss}}
\end{itemize}
Oba te typy narzędzi posiadają swoich przedstawicieli, na których będzie można się skupić podczas analizowania sposobu ich działania.


\chapter{Module bundler}
\emph{Module budler} to -- jak wspomniano wyżej -- narzędzie służące do "sklejenia" kodu znajdującego się w wielu plikach w jeden duży plik. Służy to kilku celom:
\begin{itemize}
    \item Zmniejszenie ilości zapytań do serwera -- Duże, komercyjne aplikacje nierzadko składają się z setek lub tysięcy plików. Wdrożenie aplikacji rozdzielonej w taki sposób wiązało by się z wysyłaniem setek lub tysięcy zapytań z przeglądarki na serwer podczas każdorazowego odwiedzenia strony. Byłoby to duże obciążenie dla przeglądarki oraz ogromne obciążenie dla serwera.
    \item Utrzymanie kompatybilności wstecznej -- Specyfikacja javascript pozwala na importowanie oraz eksportowanie symboli z oraz do plików, jednak zostało to zaimplementowane w najpopularniejszych przeglądarkach stosunkowo niedawno -- pierwsze wersje Google Chrome, Opery oraz Safari wspierające javascriptowe moduły zostały wydane w 2017 roku. Rok później dołączyły do nich Mozilla Firefox oraz Microsoft Edge.\cite{es6_modules_support}
\end{itemize}

Istnieje kilka formatów modułów javascript. Najpopularniejsze z nich to UMD, CommonJS oraz format opisany w specyfikacji ES6, przy czym UMD jest w ostatnich latach coraz rzadziej używany.\cite{es6_for_humans}

Module bundler stworzony przeze mnie wspiera zarówno CommonJS jak i ES6. Format opisany w specyfikacji ES6 staje się coraz bardziej popularny, i możemy przewidywać, że w przyszłości wyprze format CommonJS, na co może wskazywać chociażby to, że obecnie został on zaimplementowany tak w przeglądarkach, jak i w środowisku Node.js, które wcześniej wspierało tylko CommonJS\cite{nodejs_modules}. Z tego powodu mój module bundler skupia się na ES6, jednak nie można było pominąć formatu CommonJS -- Używa go ogromna część najpopularniejszych bibliotek javascriptowych, w tym np. React. Aby kod tych bibliotek został poprawnie zaimportowany w aplikacji module bundler musi wspierać format, w jakim jest stworzona biblioteka.


\section{Sposoby bundlowania}
% https://parceljs.org/features/scope-hoisting/
Większość module bundlerów używa jednego z dwóch sposobów na bundlowanie modułów: Korzystająć z IIFE lub używając techniki zwanej Scope Hoisting, z czego ta druga z nich jest zdecydowanie częściej używana\cite{parcel_scope_hoisting}.

Scope hoisting polega na "wrzuceniu" zawartości każdego modułu do jednego pliku, jednocześnie zmieniając nazwy wszystkich symboli w tym module, takich jak klasy, zmienne, stałe lub metody. Każda z takich nazw staje się unikalna dla modułu, tak, aby symbole o takiej samej nazwie pochodzące z różnych modułów w pliku wyjściowym miały inną nazwę.

Oto przykład demonstrujący scope hoisting. Na wejściu mamy dwa pliki, "math.js" oraz "index.js".

math.js:
\begin{verbatim}
export function add(a, b) {
  return a + b;
}

export function square(a) {
  return a * a;
}
\end{verbatim}

index.js:
\begin{verbatim}
import {add, square} from './math';

console.log(add(2, 3));
console.log(square(5));
\end{verbatim}

Kod taki zbundlowany przy pomocy metody scope hoisting mógłby wyglądać na przykład tak:

\begin{verbatim}
function $fa6943ce8a6b29$add(a, b) {
  return a + b;
}

function $fa6943ce8a6b29$square(a) {
  return a * a;
}

console.log($fa6943ce8a6b29$add(2, 3));
console.log($fa6943ce8a6b29$square(5));
\end{verbatim}

Druga najczęściej używana metoda polega na reprezentacji każdego modułu jako funkcji. W momencie, kiedy jeden moduł importuje pewne symbole z innego modułu, metoda reprezentująca zaimportowany moduł jest wykonywana. Następnie zwrócone wyniki zostają dostarczone do modułu importującego, a także zapisane w cache. Kiedy koejny moduł zaimportuje coś z tego samego modułu, funkcja nie wykona się kolejny raz. Zamiast tego, moduł dostanie wyniki z cache. Jest to istotne, ponieważ w specyfikacji Javascript moduły są singletonami. Oznacza to, że kiedy dwa moduły zaimportują te same symbole z innego modułu, oba dostaną te same symbole, a nie identyczne kopie. Jeśli więc jeden z tych kodułów w jakiś sposób zmieni coś w jednym z zaimportowanych symboli, będzie to także miało effekt w drugim module, który zaimportował ten symbol.

Ja w swoim module bundlerze zdecydowałem się skorzystać z drugiej metody.


\section{Transformacja kodu javascript przy użyciu parsera}
\section{Zależności cykliczne}
\section{Testowanie module bundlera}

\chapter{Generator CSSowych klas atomicznych}
Tradycyjne podejście do pisania kodu CSS polega wybieraniu konkretnych elementów html a następnie nadawaniu im serii reguł. Na przykład, mając na stronie okno dialogowe posiadające klasę ".dialog" w pliku CSS określili byśmy, że każdy element posiadający klasę ".dialog" musi być ponad wszystkimi innymi elementami, musi być wyśrodkowany na stronie, musi mieć białe tło oraz ciemny cień.

Problemy z takim podejściem pojawiają się, kiedy chcemy nadać style bardziej specyficznym stylom. Kontynuując poprzedni przykład, załóżmy, że w naszym oknie dialogowym posiadamy przycisk, wewnątrz którego znajduje się element <img> wyświetlający kółko sugerujące że ma miejsce jakaś akcja i przed naciśnięciem przycisku należy poczekać na jej zakończenie. Zazwyczaj takie ikony koła, zwane loaderami obracają się wokół własnej osi. Taki ruch najłatwiej wymusić poprzez style CSS. Aby jednak nadać jakieś reguły temu elementowi, musimy napisać selektor, który mówi o tym, że chcemy wybrać element <img>, który znajduje się wewnątrz elementu <button>, który znajduje się wewnątrz elementu posiadającego klasę ".dialog".

Takie podejście ma swoje wady, jednym z nich jest potrzeba odzwierciedlenia struktury html wewnątrz pliku css, co jest żmudne oraz niepewne, biorąc pod uwagę, że struktura może się w pewnym momencie zmienić.

Alternatywnym podejściem, wolnym od tych problemów jest użycie klas atomicznych.


\section{Czym są klasy atomiczne?}
Klasy atomiczne to CSSowe klasy, które mają do siebie przyporządkowaną tylko jedną regułę CSS. Klasa ".dialog" opisywana wyżej nie jest klasą atomiczną, jednak można ją zastąpić kilkoma innymi klasami atomicznymi:
\begin{itemize}
    \item klasa z regułą określającą, że element z tą klasą musi być wyświetlany ponad wszystkimi innymi, np. ".z-10000" i odpowiadająca jej reguła "z-index: 10000"
    \item kilka klas z regułami powalającymi wycentrować element, np. "display: flex" oraz "align-items: center"
    \item klasa z regułą odpowiadająca kolorowi tła, np. ".bg-white" i reguła: "background-color: white"
    \item klasa z regułą definującą cień
\end{itemize}

Chcąc sprawić, aby nasz loader się obracał, wystarczyłoby nadać mu osdowiednią klasę atomiczną, np. ".spin". W ten sposób nie polegalibyśmy już na strukturze HTML, tak, jak robiliśmy to w poprzednim podejściu.


\section{Powody używania generatora klas atomicznych}
Co łatwo zauważyć, podejście takie wymaga napisania dużej ilości klas CSSowych, co jest żmudnym zajęciem. W przeszłości z tym problemem radzono sobie używając zewnętrznych bibliotek. W ten sposób w przeszłości działał np. tailwind - dostarczał on zbiór bardzo wielu klas atomicznych, których następnie developer używał do nadawania stylów elementom HTMLowym. W ramach jednego projektu używano jednak najczęściej tylko niewielką część wszystkich dostarczonych klas. Cała reszta była niepotrzebna, a jednak dalej znajdowała się w pliku, zwiększając jego rozmiar, jednocześnie opóźniając pełne załadowanie stylów w przeglądarce.

Wiązał się z tym także kolejny problem - jakkolwiek zestaw klas był bardzo bogaty, dalej nie pokrywał on wszystkich możliwych potrzeb -- na przykład nie można stworzyć takiej ilości klas, które pozwalały by na nadanie dowolnego możliwego koloru tła.

Sposobem na poradzenie sobie z tymi problemami jest generowanie klas na etapie budowania projektu -- nie można przewidzieć wszystkich potrzebnych developerowi klas, ale można sprawdzić, jakich klas użył, a następnie wygenerować je razem z odpowiadającymi im regułami.


\section{Sposób działania}

% \section{Stworzone reguły generowania klas} % TODO jeśli będzie zbyt mało tekstu i trzeba będzie coś dopisać

\chapter{Przykładowa aplikacja stworzona przy użyciu zaprezentowanych narzędzi}

\chapter{Podsumowanie i wnioski}


\begin{thebibliography}{9}
% \bibitem{wymagania}
% \textit{Zarządzenie nr 34 Rektora Szkoły Głównej Gospodarstwa Wiejskiego w Warszawie z dnia 01 czerwca 2016 r.\ w~ sprawie wprowadzenia ,,Wytycznych dotyczących
% przygotowywania prac dyplomowych w~Szkole Głównej Gospodarstwa Wiejskiego w Warszawie''}, Załączniki 1 i~2
% \url{https://www.sggw.pl/dla-studentow/informacje-formalno-prawne/dokumenty-do-pobrania}
% $\rightarrow$ Praca dyplomowa (dostęp: 04.01.2017)
% \bibitem{latexclass}
% \textit{\LaTeXe\ for class and package writers} \url{http://www.latex-project.org/help/documentation/} $\rightarrow$ LaTeX2e for class... (dostęp 04.01.2017)
% \bibitem{latexcompanion}
% Frank Mittelbach and Michel Goossens with Johannes Braams, David Carlisle and Chris Rowley,
% \textit{The \LaTeX\ Companion}. Second Edition,
% Addison-Wesley, 2004.
% \bibitem{tds}
% \textit{A Directory Structure for \TeX\ Files} \url{http://tug.org/tds/tds.html} (dostęp 11.01.2017)
\bibitem{Tailwind_jit}
\textit{Just-in-Time Mode -- Tailwind CSS}
\url{https://v2.tailwindcss.com/docs/just-in-time-mode} (dostęp 28.02.2022)

\bibitem{unocss}
\textit{Repozytorium projektu UnoCSS w serwisie Github}
\url{https://github.com/unocss/unocss} (dostęp 28.02.2022)

\bibitem{Exploring_JS}
Axel Rauschmayer, \textit{Exploring JS}

\bibitem{es6_modules_support}
\textit{JavaScript modules -- JavaScript | MDN}
\url{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules#browser_support} (dostęp 15.03.2022)

\bibitem{es6_for_humans}
Grover D., Kunduru H.P. (2017) ES6 for Humans. Apress, Berkeley, CA.

\bibitem{nodejs_modules}
\textit{Modules: ECMAScript modules -- Node.js v17.7.1 documentation}
\url{https://nodejs.org/api/esm.html} (dostęp 15.03.2022)

\bibitem{parcel_scope_hoisting}
\textit{Scope hoisting -- Parcel.js documentation}
\url{https://parceljs.org/features/scope-hoisting/} (dostęp 15.03.2022)

\end{thebibliography}

\beforelastpage

\end{document}
